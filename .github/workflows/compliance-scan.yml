name: AI Compliance Scan

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main, master, develop]

permissions:
  contents: read
  pull-requests: write

jobs:
  compliance-scan:
    name: ğŸ›¡ï¸ Compliance Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Changed Files
        id: files
        uses: tj-actions/changed-files@v44
        with:
          files: '**/*.{java,py,js,ts,tf,yaml,yml,json}'

      - name: Cleanup Old Summary Comments
        uses: actions/github-script@v7
        with:
          script: |
            // Delete ONLY old summary comments (keep inline review comments on code)
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            let deleted = 0;
            for (const c of comments) {
              if (c.user?.login === 'github-actions[bot]') {
                try {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: c.id
                  });
                  deleted++;
                  console.log(`Deleted summary comment: ${c.id}`);
                } catch (e) {
                  console.log(`Failed to delete ${c.id}: ${e.message}`);
                }
              }
            }
            console.log(`Deleted ${deleted} old summary comments`);
            
            // Also delete old review BODIES (the "suggested changes" headers)
            // but this keeps the inline comments on specific lines
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            for (const review of reviews) {
              if (review.user?.login === 'github-actions[bot]' && review.state !== 'PENDING') {
                try {
                  // Dismiss old reviews to clean up "suggested changes" messages
                  await github.rest.pulls.dismissReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    review_id: review.id,
                    message: 'Superseded by new scan'
                  });
                  console.log(`Dismissed review: ${review.id}`);
                } catch (e) {
                  console.log(`Could not dismiss review ${review.id}: ${e.message}`);
                }
              }
            }
            
            console.log('Cleanup complete');

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: pip install google-generativeai

      - name: Run Scan
        id: scan
        env:
          CHANGED_FILES: ${{ steps.files.outputs.all_changed_files }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: python .github/scripts/compliance_scanner.py

      - name: Post Inline Comments
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('scan_report.json')) return;
            
            const report = JSON.parse(fs.readFileSync('scan_report.json', 'utf8'));
            const findings = [...(report.blocking_issues || []), ...(report.suggestions || [])];
            
            if (findings.length === 0) {
              console.log('No findings to post');
              return;
            }
            
            // Get PR info for commit SHA
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Build inline comments for code lines
            const comments = [];
            for (const f of findings) {
              if (!f.file || !f.line) continue;
              
              const sev = (f.severity || 'low').toUpperCase();
              const icon = sev === 'CRITICAL' ? 'ğŸ”´' : sev === 'HIGH' ? 'ğŸŸ ' : sev === 'MEDIUM' ? 'ğŸŸ¡' : 'ğŸ”µ';
              
              let body = `### ${icon} ${sev}: ${f.title}\n\n`;
              if (f.cve_id) body += `**CVE:** ${f.cve_id}\n`;
              if (f.cwe_id) body += `**CWE:** ${f.cwe_id}\n`;
              body += `**SCF:** ${f.scf_control || 'N/A'}\n\n`;
              body += `**Issue:** ${f.description || 'Security issue detected'}\n\n`;
              body += `**Fix:** ${f.remediation || 'Review and fix'}\n`;
              
              comments.push({
                path: f.file,
                line: parseInt(f.line) || 1,
                body: body
              });
            }
            
            // Create review with inline comments
            if (comments.length > 0) {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  commit_id: pr.head.sha,
                  event: 'COMMENT',
                  comments: comments.slice(0, 30)
                });
                console.log(`Posted ${comments.length} inline comments`);
              } catch (e) {
                console.log('Failed to post inline comments:', e.message);
              }
            }

      - name: Post Summary Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('scan_report.json')) return;
            
            const report = JSON.parse(fs.readFileSync('scan_report.json', 'utf8'));
            const findings = [...(report.blocking_issues || []), ...(report.suggestions || [])];
            const s = report.summary || {};
            const ai = report.ai_insights || {};
            
            // Build summary
            let summary = report.decision === 'BLOCK' ? '## ğŸš« Compliance Check Failed\n\n' : '## âœ… Compliance Check Passed\n\n';
            
            summary += `| Severity | Count | | Metric | Value |\n`;
            summary += `|----------|-------|-|--------|-------|\n`;
            summary += `| ğŸ”´ Critical | ${s.critical || 0} | | Risk Score | ${ai.risk_score || 0}/10 |\n`;
            summary += `| ğŸŸ  High | ${s.high || 0} | | Files Scanned | ${ai.files_scanned || 0} |\n`;
            summary += `| ğŸŸ¡ Medium | ${s.medium || 0} | | Findings | ${findings.length} |\n`;
            summary += `| ğŸ”µ Low | ${s.low || 0} | | AI Powered | âœ… |\n\n`;
            
            if (ai.executive_summary) {
              summary += `> ${ai.executive_summary}\n\n`;
            }
            
            // Compliance mapping
            const controls = new Set();
            findings.forEach(f => { if (f.scf_control) controls.add(f.scf_control); });
            if (controls.size > 0) {
              summary += `**SCF Controls Violated:** ${[...controls].join(', ')}\n\n`;
            }
            
            summary += `ğŸ“ **See inline comments on code for details and fixes**\n\n`;
            
            summary += `<details><summary>ğŸ“ Audit Evidence</summary>\n\n`;
            summary += `- Scan: ${new Date().toISOString()}\n`;
            summary += `- PR: #${context.issue.number}\n`;
            summary += `- Commit: ${context.payload.pull_request?.head?.sha?.substring(0, 7) || 'N/A'}\n`;
            summary += `</details>\n\n`;
            
            summary += `---\n*ğŸ¤– AI Compliance-as-Code Bot | Google Gemini*`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });

      - name: Fail if Blocked
        if: steps.scan.outputs.decision == 'BLOCK'
        run: exit 1
