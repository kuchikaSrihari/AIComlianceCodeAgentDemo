name: SecureFlow AI

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main, master, develop]

permissions:
  contents: read
  pull-requests: write

jobs:
  compliance-scan:
    name: üõ°Ô∏è Compliance Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Changed Files
        id: files
        uses: tj-actions/changed-files@v44
        with:
          files: '**/*.{java,py,js,ts,tf,yaml,yml,json}'

      - name: Cleanup ALL Old Bot Comments
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = context.issue.number;
            
            console.log('üßπ Cleaning up ALL old bot comments (with pagination)...');
            
            // 1. Delete ALL issue comments (summary) - WITH PAGINATION
            let deletedIssue = 0;
            let page = 1;
            while (true) {
              const { data: comments } = await github.rest.issues.listComments({
                owner, repo, issue_number: pull_number, per_page: 100, page
              });
              if (comments.length === 0) break;
              
              for (const c of comments) {
                if (c.user?.login === 'github-actions[bot]') {
                  try {
                    await github.rest.issues.deleteComment({ owner, repo, comment_id: c.id });
                    deletedIssue++;
                  } catch (e) { /* ignore */ }
                }
              }
              page++;
              if (comments.length < 100) break;
            }
            console.log(`Deleted ${deletedIssue} summary comments`);
            
            // 2. Delete ALL review comments (inline) - WITH PAGINATION
            let deletedReview = 0;
            page = 1;
            while (true) {
              const { data: comments } = await github.rest.pulls.listReviewComments({
                owner, repo, pull_number, per_page: 100, page
              });
              if (comments.length === 0) break;
              
              for (const c of comments) {
                if (c.user?.login === 'github-actions[bot]') {
                  try {
                    await github.rest.pulls.deleteReviewComment({ owner, repo, comment_id: c.id });
                    deletedReview++;
                  } catch (e) { /* ignore */ }
                }
              }
              page++;
              if (comments.length < 100) break;
            }
            console.log(`Deleted ${deletedReview} inline comments`);
            
            console.log(`‚úÖ Total cleaned: ${deletedIssue + deletedReview} comments`);

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: pip install google-generativeai

      - name: Run Scan
        id: scan
        env:
          CHANGED_FILES: ${{ steps.files.outputs.all_changed_files }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: python .github/scripts/compliance_scanner.py

      - name: Post Inline Comments
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('scan_report.json')) return;
            
            const report = JSON.parse(fs.readFileSync('scan_report.json', 'utf8'));
            const findings = [...(report.blocking_issues || []), ...(report.suggestions || [])];
            
            if (findings.length === 0) {
              console.log('No findings to post');
              return;
            }
            
            // Get PR info for commit SHA
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // ONLY post inline comments for CRITICAL and HIGH severity
            const comments = [];
            
            for (const f of findings) {
              const sev = (f.severity || 'low').toLowerCase();
              if (sev !== 'critical' && sev !== 'high') continue;  // Skip medium/low
              if (!f.file || !f.line) continue;
              
              const icon = sev === 'critical' ? 'üî¥' : 'üü†';
              
              // CONCISE inline comment
              let body = `**${icon} ${sev.toUpperCase()}:** ${f.title}\n\n`;
              body += `CVSS: ${f.cvss_score || 'N/A'} | ${f.owasp_category || ''} | ${f.cwe_id || ''}\n\n`;
              body += `**Fix:** ${f.remediation || 'Review and fix'}`;
              
              if (f.code_fix) {
                body += `\n\n\`\`\`\n${f.code_fix}\n\`\`\``;
              }
              
              comments.push({
                path: f.file,
                line: parseInt(f.line) || 1,
                body: body
              });
            }
            
            // Create review with inline comments
            if (comments.length > 0) {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  commit_id: pr.head.sha,
                  event: 'COMMENT',
                  comments: comments
                });
                console.log(`Posted ${comments.length} inline comments (top ${MAX_INLINE} issues)`);
              } catch (e) {
                console.log('Failed to post inline comments:', e.message);
              }
            }

      - name: Post Summary Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('scan_report.json')) return;
            
            const report = JSON.parse(fs.readFileSync('scan_report.json', 'utf8'));
            const findings = [...(report.blocking_issues || []), ...(report.suggestions || [])];
            const s = report.summary || {};
            const ai = report.ai_insights || {};
            const rm = report.risk_metrics || {};
            const comp = report.compliance || {};
            const slas = report.remediation_slas || {};
            
            // Build summary header with branded name
            let summary = `# üõ°Ô∏è SecureFlow AI\n`;
            summary += `> *Intelligent Compliance-as-Code Scanner*\n\n`;
            summary += report.decision === 'BLOCK' 
              ? '## üö´ Security Issues Found\n\n' 
              : '## ‚úÖ Security Check Passed\n\n';
            
            // Risk metrics table (SCF-GRC-01)
            summary += `### üìä Risk Assessment (SCF-GRC-01)\n\n`;
            summary += `| Severity | Count | SLA | | Risk Metric | Value |\n`;
            summary += `|----------|-------|-----|-|-------------|-------|\n`;
            summary += `| üî¥ Critical | ${s.critical || 0} | Immediate | | Risk Score | ${rm.risk_score || ai.risk_score || 0}/10 |\n`;
            summary += `| üü† High | ${s.high || 0} | 7 days | | Max CVSS | ${rm.max_cvss || 'N/A'} |\n`;
            summary += `| üü° Medium | ${s.medium || 0} | 30 days | | Avg CVSS | ${rm.avg_cvss || 'N/A'} |\n`;
            summary += `| üîµ Low | ${s.low || 0} | 90 days | | Files Scanned | ${ai.files_scanned || 0} |\n\n`;
            
            // Executive summary
            if (ai.executive_summary) {
              summary += `### üìã Executive Summary\n> ${ai.executive_summary}\n\n`;
            }
            
            // OWASP Coverage (SCF-VULN-04)
            const owaspCats = comp.owasp_categories || [];
            if (owaspCats.length > 0) {
              summary += `### üéØ OWASP Top 10 Coverage (SCF-VULN-04)\n`;
              summary += `**Categories Detected:** ${owaspCats.join(', ')}\n\n`;
            }
            
            // SCF Controls - deduplicated and concise
            const scfControls = comp.scf_controls_violated || [];
            if (scfControls.length > 0) {
              // Deduplicate and normalize control IDs
              const uniqueControls = [...new Set(scfControls.map(c => {
                // Extract main control category (e.g., "CRY-03" from "SCF-CRY-03" or "SCF-2.1.1")
                const match = c.match(/(CRY|TDA|IAC|NET|LOG|VULN|SEC|AUT|CFG)[-]?\d*/i);
                return match ? match[0].toUpperCase() : c.split(':')[0].trim();
              }))].slice(0, 8);  // Max 8 controls
              
              const controlDescs = {
                'CRY': 'üîê Cryptography', 'TDA': 'üíª Secure Coding', 'IAC': 'üîë Access Control',
                'NET': 'üåê Network Security', 'LOG': 'üìù Logging', 'VULN': 'üõ°Ô∏è Vulnerability Mgmt',
                'SEC': 'üîí Security Controls', 'AUT': 'üë§ Authentication', 'CFG': '‚öôÔ∏è Configuration'
              };
              
              const controlTags = uniqueControls.map(c => {
                const key = Object.keys(controlDescs).find(k => c.includes(k));
                return key ? controlDescs[key] : `üìã ${c}`;
              });
              
              summary += `### üèõÔ∏è Controls Violated\n`;
              summary += `${controlTags.join(' ‚Ä¢ ')}\n\n`;
            }
            
            // Remediation SLAs (SCF-GRC-14)
            if (slas.immediate > 0 || slas['7_days'] > 0) {
              summary += `### ‚è∞ Remediation Required (SCF-GRC-14)\n`;
              if (slas.immediate > 0) summary += `- **${slas.immediate} issues** require immediate remediation\n`;
              if (slas['7_days'] > 0) summary += `- **${slas['7_days']} issues** must be fixed within 7 days\n`;
              summary += `\n`;
            }
            
            // Add MEDIUM/LOW findings to summary (not inline)
            const mediumLow = findings.filter(f => 
              f.severity?.toLowerCase() === 'medium' || f.severity?.toLowerCase() === 'low'
            );
            
            if (mediumLow.length > 0) {
              summary += `### üìù Additional Findings (Medium/Low)\n\n`;
              summary += `<details><summary>Click to expand ${mediumLow.length} findings</summary>\n\n`;
              summary += `| Severity | File | Line | Issue | Fix |\n`;
              summary += `|----------|------|------|-------|-----|\n`;
              mediumLow.slice(0, 20).forEach(f => {
                const icon = f.severity?.toLowerCase() === 'medium' ? 'üü°' : 'üîµ';
                const file = f.file?.split('/').pop() || 'N/A';
                const title = (f.title || '').substring(0, 40);
                const fix = (f.remediation || '').substring(0, 50);
                summary += `| ${icon} ${f.severity} | ${file} | ${f.line || '-'} | ${title} | ${fix} |\n`;
              });
              if (mediumLow.length > 20) {
                summary += `\n*...and ${mediumLow.length - 20} more*\n`;
              }
              summary += `</details>\n\n`;
            }
            
            summary += `üìç **Critical/High issues have inline comments on the code**\n\n`;
            
            // Audit Evidence (SCF-GRC-03)
            summary += `<details><summary>üìÅ Audit Evidence (SCF-GRC-03: Control Assessment)</summary>\n\n`;
            summary += `| Field | Value |\n|-------|-------|\n`;
            summary += `| Scan Time | ${new Date().toISOString()} |\n`;
            summary += `| PR | #${context.issue.number} |\n`;
            summary += `| Commit | ${context.payload.pull_request?.head?.sha?.substring(0, 7) || 'N/A'} |\n`;
            summary += `| Branch | ${context.payload.pull_request?.head?.ref || 'N/A'} |\n`;
            summary += `| Frameworks | ${(comp.frameworks_checked || ['SCF', 'SOC2', 'HIPAA', 'PCI-DSS']).join(', ')} |\n`;
            summary += `| AI Model | Google Gemini 2.0 Flash |\n`;
            summary += `</details>\n\n`;
            
            summary += `---\n*üõ°Ô∏è **SecureFlow AI** | Powered by Google Gemini 2.0*`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });

      - name: Fail if Blocked
        if: steps.scan.outputs.decision == 'BLOCK'
        run: exit 1
