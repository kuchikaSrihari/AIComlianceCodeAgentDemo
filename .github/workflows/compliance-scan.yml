name: AI Compliance Security Scan

# Uses Google Gemini (FREE) for AI-powered code security analysis
# Add GEMINI_API_KEY to repository secrets to enable

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [main, master, develop]

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}

jobs:
  compliance-scan:
    name: Security & Compliance Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Changed Files
        id: changed-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            **/*.py
            **/*.js
            **/*.ts
            **/*.java
            **/*.tf
            **/*.yaml
            **/*.yml
            **/*.json

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Scanner Dependencies
        run: |
          pip install google-generativeai

      - name: Get Scanner from Base Branch
        run: |
          git fetch origin ${{ github.base_ref }}
          git checkout origin/${{ github.base_ref }} -- .github/scripts/compliance_scanner.py

      - name: Run AI Compliance Scan
        id: scan
        env:
          CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          echo "ü§ñ Starting AI-Powered Compliance Scan..."
          python .github/scripts/compliance_scanner.py

      # Add inline review comments on specific lines
      - name: Add Inline Review Comments
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            if (!fs.existsSync('scan_report.json')) {
              console.log('No scan report found');
              return;
            }
            
            const report = JSON.parse(fs.readFileSync('scan_report.json', 'utf8'));
            const allFindings = [...(report.blocking_issues || []), ...(report.suggestions || [])];
            
            if (allFindings.length === 0) {
              console.log('No findings to comment on');
              return;
            }
            
            // Get the PR's head SHA for review comments
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const commitId = pr.head.sha;
            
            // Create a review with inline comments
            const comments = [];
            
            for (const finding of allFindings) {
              if (!finding.file || !finding.line) continue;
              
              const severity = (finding.severity || 'info').toUpperCase();
              const emoji = severity === 'CRITICAL' ? 'üî¥' : 
                           severity === 'HIGH' ? 'üü†' : 
                           severity === 'MEDIUM' ? 'üü°' : 'üîµ';
              
              let body = `## ${emoji} ${severity}: ${finding.title}\n\n`;
              body += `**üìã Description:** ${finding.description || 'Security issue detected'}\n\n`;
              body += `**‚úÖ Remediation:** ${finding.remediation || 'Review and fix this issue'}\n\n`;
              
              if (finding.scf_control) {
                body += `**üìä Compliance:** SCF ${finding.scf_control}`;
                if (finding.soc2_control) body += ` | SOC2 ${finding.soc2_control}`;
                body += `\n\n`;
              }
              
              body += `---\n*ü§ñ AI Compliance Bot*`;
              
              comments.push({
                path: finding.file,
                line: parseInt(finding.line) || 1,
                body: body
              });
            }
            
            if (comments.length > 0) {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  commit_id: commitId,
                  event: report.decision === 'BLOCK' ? 'REQUEST_CHANGES' : 'COMMENT',
                  body: `## ü§ñ AI Compliance Scan Complete\n\n**Decision:** ${report.decision}\n**Risk Score:** ${report.ai_insights?.risk_score || 'N/A'}/10\n\nSee inline comments for details.`,
                  comments: comments
                });
                console.log(`Created review with ${comments.length} inline comments`);
              } catch (e) {
                console.log('Failed to create review:', e.message);
                // Fallback: create individual comments
                for (const c of comments) {
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: context.issue.number,
                      commit_id: commitId,
                      path: c.path,
                      line: c.line,
                      body: c.body
                    });
                  } catch (e2) {
                    console.log(`Failed to comment on ${c.path}:${c.line}:`, e2.message);
                  }
                }
              }
            }

      - name: Comment PR - Summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            if (!fs.existsSync('scan_report.json')) {
              return;
            }
            
            const report = JSON.parse(fs.readFileSync('scan_report.json', 'utf8'));
            
            let comment = report.decision === 'BLOCK' 
              ? `## üö´ Compliance Check Failed\n\n`
              : `## ‚úÖ Compliance Check Passed\n\n`;
            
            comment += `| Severity | Count |\n|----------|-------|\n`;
            comment += `| üî¥ Critical | ${report.summary?.critical || 0} |\n`;
            comment += `| üü† High | ${report.summary?.high || 0} |\n`;
            comment += `| üü° Medium | ${report.summary?.medium || 0} |\n`;
            comment += `| üîµ Low | ${report.summary?.low || 0} |\n\n`;
            
            if (report.ai_powered && report.ai_insights) {
              comment += `### ü§ñ AI Analysis\n`;
              comment += `- **Risk Score:** ${report.ai_insights.risk_score || 0}/10\n`;
              if (report.ai_insights.executive_summary) {
                comment += `- **Summary:** ${report.ai_insights.executive_summary}\n`;
              }
              comment += `\n`;
            }
            
            if (report.decision === 'BLOCK') {
              comment += `‚ö†Ô∏è **See inline comments on specific lines for details and fixes.**\n\n`;
            }
            
            comment += `---\n*ü§ñ AI Compliance-as-Code Bot | Powered by Google Gemini*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Fail if Blocked
        if: steps.scan.outputs.decision == 'BLOCK'
        run: |
          echo "::error::PR blocked due to security/compliance violations"
          exit 1

# AI (Google Gemini) analyzes code for:
# - Security vulnerabilities (secrets, injection, crypto)
# - Compliance mapping (SCF, SOC2, HIPAA, PCI-DSS)
# - Risk scoring and remediation suggestions
